---
layout: single
title:  "[인공지능] CNN 정리(컨볼루션 층, 풀링 층)"
categories: AI
tag: [python, keras, CNN, 컨볼루션, 풀링, Convolution, Pooling, 인공지능, 딥러닝, 머신러닝]
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


#### 합성곱 신경망

합성곱 신경망(Convolutional Neural Network)은 이미지 처리에 탁월한 성능을 보이는 신경망입니다.  

합성곱 신경망은 크게 합성곱층(Convolution layer)과 풀링층(Pooling layer)으로 구성됩니다.  



<br/>



이미지 처리를 하기 위해 앞서 배운 다층 퍼셉트론을 사용할 수는 있지만 한계가 있습니다.  

다층 퍼셉트론을 사용한다면 이미지를 1차원 벡터로 변환하고 입력층으로 사용해야 합니다.  

하지만, 몇가지 픽셀값만 달라져도 예측에 적지 않은 영향을 받게 되고,  

1차원 벡터로 변환하면서 공간적인 구조 정보가 유실되므로 좀 더 정확한 예측을 위해 합성곱 신경망을 사용합니다.  



<br/>



##### 채널  

이미지는 (높이, 너비, 채널)이라는 3차원 텐서입니다.  

높이는 이미지의 세로 방향 픽셀 수, 너비는 이미지의 가로 방향 픽셀 수, 채널은 색 성분을 의미합니다.  

여기서 흑백 이미지는 채널 수가 1이고,  

컬러 이미지는 적색(Red), 녹색(Green), 청색(Blue) 세가지 색깔의 조합으로 이루어지므로 채널수가 3입니다.  



<br/>



##### 필터(=커널 =가중치)  

합성곱층은 합성곱 연산을 통해 이미지의 특징을 추출하는 역할을 합니다.  

이때, 필터(커널)라는 N x M 크기의 행렬로 이미지를 처음부터 끝까지(가장 왼쪽 위부터 가장 오른쪽 아래까지)  

순차적으로 훑으면서 필터와 겹쳐지는 부분의 각 이미지와 필터의 원소(가중치) 값을 곱해서 모두 더한 값을 출력합니다.  



<br/>





아래의 그림은 채널이 1인(흑백 이미지) 2차원 합성곱일 경우 입력층에 필터를 지나쳐 출력이 되는 예시입니다.  

4x4 크기의 입력층과 2x2 크기의 필터를 합성곱 연산할 경우 3x3형태의 출력이 나옵니다.  

물론 필터에는 각 가중치가 존재하면서 편향도 존재합니다.  

예를 들어, 편향이 +1이라면 아래의 그림에 나오는 출력의 각 원소들은 +1이되어 출력이 됩니다.

이때, 만들어지는 출력을 특성맵(feature map)이라고 합니다.  

입력층이 필터와 합성곱 연산이 되고 특성맵으로 출력이 될때, 활성화 함수가 사용되는 보통 relu함수를 사용합니다.  



![Image](/assets/images/합성곱신경망_커널.png)  



<br/>



##### 여러개의 필터(커널)  

Dense층을 여러개를 사용하는 것처럼 여러개의 필터를 사용할 수 있습니다.  

당연히 필터가 여러개면 필터의 가중치는 서로 다릅니다.  

아래의 그림처럼 4x4크기의 입력에 3개의 필터와 합성곱 연산 결과 3개의 출력 즉, 3x3x3크기의 특성맵이 됩니다.  

그림에서는 필터의 크기가 3x3이었지만, 커널의 크기를 사용자가 정할 수 있습니다.  

다만, 그림에선 커널의 크기가 2x2이지만, 커널의 크기가 크면 특징을 감지하는데 효과가 떨어진다고 하여 보통 3x3 또는 5x5를 사용합니다.  



<br/>



+ 커널의 깊이(채널) = 입력 데이터의 깊이(채널)

+ 합성곱 연산 결과 : 특성 맵은 입력 데이터의 깊이와 상관없이 (높이, 너비)의 특성 맵을 얻습니다.  

(특성 맵의 채널은 1)

+ 다만, 합성곱 연산에서 다수의 커널을 사용할 경우 : 특성 맵은 (높이, 너비, 커널의 수) 크기가 됩니다.  

(특성 맵의 채널은 합성곱 연산에 사용된 커널의 수)



![Image](/assets/images/합성곱신경망_여러개의필터.png)  



<br/>



##### 스트라이드(stride)

그림에서는 커널이 입력층 위에 한 칸씩 이동(슬라이딩)하면서 합성곱 연산을 수행합니다.  

하지만, 커널의 슬라이딩 범위 또한 사용자가 정할 수 있습니다.  

이러한 이동 범위를 스트라이드(stride)라고 합니다.  

스트라이드가 2일 경우에 4x4 이미지에 2x2의 필터가 두 칸씩 이동하면서 합성곱 연산을 수행하게 됩니다.  

그렇다면, 최종적으로 2x2x3 크기의 특성 맵을 얻게 됩니다.



<br/>



##### 케라스의 합성곱 층

```python

from tensorflow import keras

keras.layers.Conv2D(10, kernel_size=(3, 3), activation='relu')

```



+ 첫번재 인자 10은 필터의 개수를 뜻합니다.

+ kernel_size는 커널(필터)의 크기를 지정하는 인자입니다.

+ 역시 activation으로 활성화 함수를 지정합니다.



<br/>



##### 패딩(padding)

+ 패딩의 목적  

위 그림에서 4x4 이미지에 2x2 필터로 합성곱 연산을 했을 때, 스트라이드가 1일 경우엔 3x3의 특성 맵을 얻었습니다.  

이처럼 합성곱 연산의 결과로 얻은 특성 맵은 입력보다 크기가 작아진다는 특성이 있습니다.  

그렇다면 합성곱 층을 여러개 쌓은다면 최종적으로 얻는 특성 맵의 크기는 처음 입력보다 매우 작아집니다.  

여러개의 합성곱 연산 이후에도 특성 맵의 크기를 동일하게 유지되도록 하는 작업을 패딩(padding)이라고 합니다.  



<br/>



패딩은 입력 이미지의 가장자리에 지정된 개수의 폭만큼 가상의 픽셀로 테두리를 추가합니다.  

주로 값을 0으로 채우는 제로 패딩(zero padding)을 사용합니다.  

그렇다면 필터의 슬라이딩 범위가 늘어나게 되고 최종적으로 얻는 특성 맵의 크기는 패딩하기 전보다 커지게 됩니다.  

아래는 4x4 크기의 이미지를 1폭 만큼 제로 패딩을 사용했을 때 모습입니다.  

![Image](/assets/images/제로패딩.png)



<br/>

 

##### 케라스의 패딩과 스트라이드 설정

```python

from tensorflow import keras

keras.layers.Conv2D(10, kernel_size=(3, 3), activation='relu', padding='same', strides=1)

```



+ padding='same' : (same 패딩) 입력값과 특성맵 크기를 동일하게 해주는 패딩입니다.  

커널을 사용하여 합성곱 연산을 했을 때, 특성맵의 사이즈가 얼마나 될지 쉽게 알 수 있습니다.

+ padding='valid' : (valid 패딩) 패딩을 사용하지 않는 옵션입니다.

+ stride는 특수한 상황이 아닌 이상, 보통 1로 설정합니다.


##### 풀링

일반적으로 합성곱 층(합성곱 연산 + 활성화 함수) 다음에는 풀링 층을 추가합니다.  

합성곱 층(컨볼루션 층)을 통해 나온 특성 맵이 크고 복잡하다면 이를 축소(다운샘플링)해야 합니다.  

이 과정을 풀링 연산(서브샘플링)이라 하며, 이러한 연산을 하는 층을 풀링 층이라고 합니다.  



<br/>



일반적으로 최대 풀링(max pooling)과 평균 풀링(average pooling)이 사용됩니다.  

최대 풀링은 정해진 구역 안에서 최댓값을 뽑아내는 방법이고,  

평균 풀링은 평균값을 뽑아내는 방법입니다. 



<br/>



아래의 그림은 4x4크기의 특성 맵을 스트라이드가 2일때, 2x2 커널로 맥스 풀링하는 모습입니다.  

![Image](/assets/images/맥스풀링.png)



<br/>



위의 그림에서 특성 맵을 맥스풀링하게 된다면 2x2의 크기, 절반으로 특성 맵이 작아지는 걸 확인할 수 있습니다.  

만약 채널이 추가된다면 즉, 컨볼루션 층이 3개가 사용되어 특성 맵이 4x4x3 크기였다면 맥스 풀링 결과는 2x2x3이 됩니다.   

차원이 여러개 있는 특성 맵에서 풀링은 각 차원마다 수행되므로 채널 차원은 변하지 않습니다.  



<br/>



+ 풀링과 합성곱의 차이  

풀링도 합성곱 연산과 유사하게 커널을 슬라이딩시켜 특성 맵을 얻으므로 유사하다고 느낄 수 있지만,  

풀링은 합성곱 연산과 달리 곱하기나(가중치) 더하는(편향) 연산이 없는 걸 확인할 수 있습니다.  

또한, 풀링 과정에서 커널이 슬라이딩할 때 서로 겹치지 않습니다.  

즉, 위의 사진에서 커널이 2x2라면 스트라이드는 2로 설정되고 겹치지 않게 이동합니다.  

커널이 3x3이면 스트라이드는 3, 커널이 4x4이면 스트라이드는 4가 됩니다.

하지만, 통상적으로 풀링은 2x2 커널을 사용합니다.



<br/>



##### 케라스의 풀링 층

```python

keras.layers.MaxPooling2D(2, strides=2, padding='valid')

```

+ 첫번째 인자 2는 2x2의 커널로 풀링하겠다는 뜻입니다.  

+ strides는 따로 지정하지 않아도 자동으로 풀링의 크기에 맞춰서 셋팅되기 때문에 굳이 지정하지 않아도 됩니다.  

+ 풀링은 패딩을 하지않고(valid패딩), 입력 크기를 줄이는게 목적이기 때문에 굳이 지정하지 않아도 됩니다.



<br/>



##### 컨볼루션 층 + 풀링 층 사용

앞서 확인한 내용들을 바탕으로 컨볼루션 층과 풀링 층은 쌍으로 보통 사용합니다.  

(컨볼루션 층 + 풀링 층) 또는 (컨볼루션 층 + 컨볼루션 층 + 풀링 층) 이런 식으로 사용하게 되는데, 

2차원 이상의 크기로 출력이 됩니다.  

그 후에 밀집층(은닉층+출력층 또는 출력층)을 사용하여 원하는 결과값을 얻기 위해 1차원 배열로 풀어서 펼쳐야 합니다.  

따라서 Flatten()함수를 사용하여 1차원 크기로 바꾸어 사용합니다.


#### 3차원 합성곱



보통 컬러 이미지를 입력 데이터로 사용한다면 3차원 배열(높이, 너비, 깊이(채널)) 크기가 됩니다.  

이러한 경우엔 커널도 동일하게 3차원으로 만들면 됩니다.  

3차원 합성곱에서 커널의 설명은 위에서 설명한 내용과 같습니다.



+ 커널의 깊이(채널) = 입력 데이터의 깊이(채널)

+ 합성곱 연산 결과 : 특성 맵은 입력 데이터의 깊이와 상관없이 (높이, 너비)의 특성 맵을 얻습니다.  

(특성 맵의 채널은 1)

+ 다만, 합성곱 연산에서 다수의 커널을 사용할 경우 : 특성 맵은 (높이, 너비, 커널의 수) 크기가 됩니다.  

(특성 맵의 채널은 합성곱 연산에 사용된 커널의 수)

